// Code generated by gotdgen, DO NOT EDIT.

package tdapi

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdjson"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// Message represents TL type `message#e31da9f9`.
type Message struct {
	// Message identifier; unique for the chat to which the message belongs
	ID int64
	// The sender of the message
	Sender MessageSenderClass
	// Chat identifier
	ChatID int64
	// The sending state of the message; may be null
	SendingState MessageSendingStateClass
	// The scheduling state of the message; may be null
	SchedulingState MessageSchedulingStateClass
	// True, if the message is outgoing
	IsOutgoing bool
	// True, if the message is pinned
	IsPinned bool
	// True, if the message can be edited. For live location and poll messages this fields
	// shows whether editMessageLiveLocation or stopPoll can be used with this message by the
	// application
	CanBeEdited bool
	// True, if the message can be forwarded
	CanBeForwarded bool
	// True, if the message can be deleted only for the current user while other users will
	// continue to see it
	CanBeDeletedOnlyForSelf bool
	// True, if the message can be deleted for all users
	CanBeDeletedForAllUsers bool
	// True, if the message statistics are available
	CanGetStatistics bool
	// True, if the message thread info is available
	CanGetMessageThread bool
	// True, if chat members already viewed the message can be received through
	// getMessageViewers
	CanGetViewers bool
	// True, if media timestamp links can be generated for media timestamp entities in the
	// message text, caption or web page description
	CanGetMediaTimestampLinks bool
	// True, if media timestamp entities refers to a media in this message as opposed to a
	// media in the replied message
	HasTimestampedMedia bool
	// True, if the message is a channel post. All messages to channels are channel posts,
	// all other messages are not channel posts
	IsChannelPost bool
	// True, if the message contains an unread mention for the current user
	ContainsUnreadMention bool
	// Point in time (Unix timestamp) when the message was sent
	Date int32
	// Point in time (Unix timestamp) when the message was last edited
	EditDate int32
	// Information about the initial message sender; may be null
	ForwardInfo MessageForwardInfo
	// Information about interactions with the message; may be null
	InteractionInfo MessageInteractionInfo
	// If non-zero, the identifier of the chat to which the replied message belongs;
	// Currently, only messages in the Replies chat can have different reply_in_chat_id and
	// chat_id
	ReplyInChatID int64
	// If non-zero, the identifier of the message this message is replying to; can be the
	// identifier of a deleted message
	ReplyToMessageID int64
	// If non-zero, the identifier of the message thread the message belongs to; unique
	// within the chat to which the message belongs
	MessageThreadID int64
	// For self-destructing messages, the message's TTL (Time To Live), in seconds; 0 if none
	// TDLib will send updateDeleteMessages or updateMessageContent once the TTL expires
	TTL int32
	// Time left before the message expires, in seconds. If the TTL timer isn't started yet,
	// equals to the value of the ttl field
	TTLExpiresIn float64
	// If non-zero, the user identifier of the bot through which this message was sent
	ViaBotUserID int64
	// For channel posts and anonymous group messages, optional author signature
	AuthorSignature string
	// Unique identifier of an album this message belongs to. Only audios, documents, photos
	// and videos can be grouped together in albums
	MediaAlbumID int64
	// If non-empty, contains a human-readable description of the reason why access to this
	// message must be restricted
	RestrictionReason string
	// Content of the message
	Content MessageContentClass
	// Reply markup for the message; may be null
	ReplyMarkup ReplyMarkupClass
}

// MessageTypeID is TL type id of Message.
const MessageTypeID = 0xe31da9f9

// Ensuring interfaces in compile-time for Message.
var (
	_ bin.Encoder     = &Message{}
	_ bin.Decoder     = &Message{}
	_ bin.BareEncoder = &Message{}
	_ bin.BareDecoder = &Message{}
)

func (m *Message) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.ID == 0) {
		return false
	}
	if !(m.Sender == nil) {
		return false
	}
	if !(m.ChatID == 0) {
		return false
	}
	if !(m.SendingState == nil) {
		return false
	}
	if !(m.SchedulingState == nil) {
		return false
	}
	if !(m.IsOutgoing == false) {
		return false
	}
	if !(m.IsPinned == false) {
		return false
	}
	if !(m.CanBeEdited == false) {
		return false
	}
	if !(m.CanBeForwarded == false) {
		return false
	}
	if !(m.CanBeDeletedOnlyForSelf == false) {
		return false
	}
	if !(m.CanBeDeletedForAllUsers == false) {
		return false
	}
	if !(m.CanGetStatistics == false) {
		return false
	}
	if !(m.CanGetMessageThread == false) {
		return false
	}
	if !(m.CanGetViewers == false) {
		return false
	}
	if !(m.CanGetMediaTimestampLinks == false) {
		return false
	}
	if !(m.HasTimestampedMedia == false) {
		return false
	}
	if !(m.IsChannelPost == false) {
		return false
	}
	if !(m.ContainsUnreadMention == false) {
		return false
	}
	if !(m.Date == 0) {
		return false
	}
	if !(m.EditDate == 0) {
		return false
	}
	if !(m.ForwardInfo.Zero()) {
		return false
	}
	if !(m.InteractionInfo.Zero()) {
		return false
	}
	if !(m.ReplyInChatID == 0) {
		return false
	}
	if !(m.ReplyToMessageID == 0) {
		return false
	}
	if !(m.MessageThreadID == 0) {
		return false
	}
	if !(m.TTL == 0) {
		return false
	}
	if !(m.TTLExpiresIn == 0) {
		return false
	}
	if !(m.ViaBotUserID == 0) {
		return false
	}
	if !(m.AuthorSignature == "") {
		return false
	}
	if !(m.MediaAlbumID == 0) {
		return false
	}
	if !(m.RestrictionReason == "") {
		return false
	}
	if !(m.Content == nil) {
		return false
	}
	if !(m.ReplyMarkup == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *Message) String() string {
	if m == nil {
		return "Message(nil)"
	}
	type Alias Message
	return fmt.Sprintf("Message%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*Message) TypeID() uint32 {
	return MessageTypeID
}

// TypeName returns name of type in TL schema.
func (*Message) TypeName() string {
	return "message"
}

// TypeInfo returns info about TL type.
func (m *Message) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "message",
		ID:   MessageTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "Sender",
			SchemaName: "sender",
		},
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "SendingState",
			SchemaName: "sending_state",
		},
		{
			Name:       "SchedulingState",
			SchemaName: "scheduling_state",
		},
		{
			Name:       "IsOutgoing",
			SchemaName: "is_outgoing",
		},
		{
			Name:       "IsPinned",
			SchemaName: "is_pinned",
		},
		{
			Name:       "CanBeEdited",
			SchemaName: "can_be_edited",
		},
		{
			Name:       "CanBeForwarded",
			SchemaName: "can_be_forwarded",
		},
		{
			Name:       "CanBeDeletedOnlyForSelf",
			SchemaName: "can_be_deleted_only_for_self",
		},
		{
			Name:       "CanBeDeletedForAllUsers",
			SchemaName: "can_be_deleted_for_all_users",
		},
		{
			Name:       "CanGetStatistics",
			SchemaName: "can_get_statistics",
		},
		{
			Name:       "CanGetMessageThread",
			SchemaName: "can_get_message_thread",
		},
		{
			Name:       "CanGetViewers",
			SchemaName: "can_get_viewers",
		},
		{
			Name:       "CanGetMediaTimestampLinks",
			SchemaName: "can_get_media_timestamp_links",
		},
		{
			Name:       "HasTimestampedMedia",
			SchemaName: "has_timestamped_media",
		},
		{
			Name:       "IsChannelPost",
			SchemaName: "is_channel_post",
		},
		{
			Name:       "ContainsUnreadMention",
			SchemaName: "contains_unread_mention",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
		{
			Name:       "EditDate",
			SchemaName: "edit_date",
		},
		{
			Name:       "ForwardInfo",
			SchemaName: "forward_info",
		},
		{
			Name:       "InteractionInfo",
			SchemaName: "interaction_info",
		},
		{
			Name:       "ReplyInChatID",
			SchemaName: "reply_in_chat_id",
		},
		{
			Name:       "ReplyToMessageID",
			SchemaName: "reply_to_message_id",
		},
		{
			Name:       "MessageThreadID",
			SchemaName: "message_thread_id",
		},
		{
			Name:       "TTL",
			SchemaName: "ttl",
		},
		{
			Name:       "TTLExpiresIn",
			SchemaName: "ttl_expires_in",
		},
		{
			Name:       "ViaBotUserID",
			SchemaName: "via_bot_user_id",
		},
		{
			Name:       "AuthorSignature",
			SchemaName: "author_signature",
		},
		{
			Name:       "MediaAlbumID",
			SchemaName: "media_album_id",
		},
		{
			Name:       "RestrictionReason",
			SchemaName: "restriction_reason",
		},
		{
			Name:       "Content",
			SchemaName: "content",
		},
		{
			Name:       "ReplyMarkup",
			SchemaName: "reply_markup",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *Message) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode message#e31da9f9 as nil")
	}
	b.PutID(MessageTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *Message) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode message#e31da9f9 as nil")
	}
	b.PutLong(m.ID)
	if m.Sender == nil {
		return fmt.Errorf("unable to encode message#e31da9f9: field sender is nil")
	}
	if err := m.Sender.Encode(b); err != nil {
		return fmt.Errorf("unable to encode message#e31da9f9: field sender: %w", err)
	}
	b.PutLong(m.ChatID)
	if m.SendingState == nil {
		return fmt.Errorf("unable to encode message#e31da9f9: field sending_state is nil")
	}
	if err := m.SendingState.Encode(b); err != nil {
		return fmt.Errorf("unable to encode message#e31da9f9: field sending_state: %w", err)
	}
	if m.SchedulingState == nil {
		return fmt.Errorf("unable to encode message#e31da9f9: field scheduling_state is nil")
	}
	if err := m.SchedulingState.Encode(b); err != nil {
		return fmt.Errorf("unable to encode message#e31da9f9: field scheduling_state: %w", err)
	}
	b.PutBool(m.IsOutgoing)
	b.PutBool(m.IsPinned)
	b.PutBool(m.CanBeEdited)
	b.PutBool(m.CanBeForwarded)
	b.PutBool(m.CanBeDeletedOnlyForSelf)
	b.PutBool(m.CanBeDeletedForAllUsers)
	b.PutBool(m.CanGetStatistics)
	b.PutBool(m.CanGetMessageThread)
	b.PutBool(m.CanGetViewers)
	b.PutBool(m.CanGetMediaTimestampLinks)
	b.PutBool(m.HasTimestampedMedia)
	b.PutBool(m.IsChannelPost)
	b.PutBool(m.ContainsUnreadMention)
	b.PutInt32(m.Date)
	b.PutInt32(m.EditDate)
	if err := m.ForwardInfo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode message#e31da9f9: field forward_info: %w", err)
	}
	if err := m.InteractionInfo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode message#e31da9f9: field interaction_info: %w", err)
	}
	b.PutLong(m.ReplyInChatID)
	b.PutLong(m.ReplyToMessageID)
	b.PutLong(m.MessageThreadID)
	b.PutInt32(m.TTL)
	b.PutDouble(m.TTLExpiresIn)
	b.PutLong(m.ViaBotUserID)
	b.PutString(m.AuthorSignature)
	b.PutLong(m.MediaAlbumID)
	b.PutString(m.RestrictionReason)
	if m.Content == nil {
		return fmt.Errorf("unable to encode message#e31da9f9: field content is nil")
	}
	if err := m.Content.Encode(b); err != nil {
		return fmt.Errorf("unable to encode message#e31da9f9: field content: %w", err)
	}
	if m.ReplyMarkup == nil {
		return fmt.Errorf("unable to encode message#e31da9f9: field reply_markup is nil")
	}
	if err := m.ReplyMarkup.Encode(b); err != nil {
		return fmt.Errorf("unable to encode message#e31da9f9: field reply_markup: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *Message) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode message#e31da9f9 to nil")
	}
	if err := b.ConsumeID(MessageTypeID); err != nil {
		return fmt.Errorf("unable to decode message#e31da9f9: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *Message) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode message#e31da9f9 to nil")
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field id: %w", err)
		}
		m.ID = value
	}
	{
		value, err := DecodeMessageSender(b)
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field sender: %w", err)
		}
		m.Sender = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field chat_id: %w", err)
		}
		m.ChatID = value
	}
	{
		value, err := DecodeMessageSendingState(b)
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field sending_state: %w", err)
		}
		m.SendingState = value
	}
	{
		value, err := DecodeMessageSchedulingState(b)
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field scheduling_state: %w", err)
		}
		m.SchedulingState = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field is_outgoing: %w", err)
		}
		m.IsOutgoing = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field is_pinned: %w", err)
		}
		m.IsPinned = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field can_be_edited: %w", err)
		}
		m.CanBeEdited = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field can_be_forwarded: %w", err)
		}
		m.CanBeForwarded = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field can_be_deleted_only_for_self: %w", err)
		}
		m.CanBeDeletedOnlyForSelf = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field can_be_deleted_for_all_users: %w", err)
		}
		m.CanBeDeletedForAllUsers = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field can_get_statistics: %w", err)
		}
		m.CanGetStatistics = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field can_get_message_thread: %w", err)
		}
		m.CanGetMessageThread = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field can_get_viewers: %w", err)
		}
		m.CanGetViewers = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field can_get_media_timestamp_links: %w", err)
		}
		m.CanGetMediaTimestampLinks = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field has_timestamped_media: %w", err)
		}
		m.HasTimestampedMedia = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field is_channel_post: %w", err)
		}
		m.IsChannelPost = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field contains_unread_mention: %w", err)
		}
		m.ContainsUnreadMention = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field date: %w", err)
		}
		m.Date = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field edit_date: %w", err)
		}
		m.EditDate = value
	}
	{
		if err := m.ForwardInfo.Decode(b); err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field forward_info: %w", err)
		}
	}
	{
		if err := m.InteractionInfo.Decode(b); err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field interaction_info: %w", err)
		}
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field reply_in_chat_id: %w", err)
		}
		m.ReplyInChatID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field reply_to_message_id: %w", err)
		}
		m.ReplyToMessageID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field message_thread_id: %w", err)
		}
		m.MessageThreadID = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field ttl: %w", err)
		}
		m.TTL = value
	}
	{
		value, err := b.Double()
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field ttl_expires_in: %w", err)
		}
		m.TTLExpiresIn = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field via_bot_user_id: %w", err)
		}
		m.ViaBotUserID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field author_signature: %w", err)
		}
		m.AuthorSignature = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field media_album_id: %w", err)
		}
		m.MediaAlbumID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field restriction_reason: %w", err)
		}
		m.RestrictionReason = value
	}
	{
		value, err := DecodeMessageContent(b)
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field content: %w", err)
		}
		m.Content = value
	}
	{
		value, err := DecodeReplyMarkup(b)
		if err != nil {
			return fmt.Errorf("unable to decode message#e31da9f9: field reply_markup: %w", err)
		}
		m.ReplyMarkup = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *Message) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode message#e31da9f9 as nil")
	}
	b.ObjStart()
	b.PutID("message")
	b.FieldStart("id")
	b.PutLong(m.ID)
	b.FieldStart("sender")
	if m.Sender == nil {
		return fmt.Errorf("unable to encode message#e31da9f9: field sender is nil")
	}
	if err := m.Sender.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode message#e31da9f9: field sender: %w", err)
	}
	b.FieldStart("chat_id")
	b.PutLong(m.ChatID)
	b.FieldStart("sending_state")
	if m.SendingState == nil {
		return fmt.Errorf("unable to encode message#e31da9f9: field sending_state is nil")
	}
	if err := m.SendingState.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode message#e31da9f9: field sending_state: %w", err)
	}
	b.FieldStart("scheduling_state")
	if m.SchedulingState == nil {
		return fmt.Errorf("unable to encode message#e31da9f9: field scheduling_state is nil")
	}
	if err := m.SchedulingState.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode message#e31da9f9: field scheduling_state: %w", err)
	}
	b.FieldStart("is_outgoing")
	b.PutBool(m.IsOutgoing)
	b.FieldStart("is_pinned")
	b.PutBool(m.IsPinned)
	b.FieldStart("can_be_edited")
	b.PutBool(m.CanBeEdited)
	b.FieldStart("can_be_forwarded")
	b.PutBool(m.CanBeForwarded)
	b.FieldStart("can_be_deleted_only_for_self")
	b.PutBool(m.CanBeDeletedOnlyForSelf)
	b.FieldStart("can_be_deleted_for_all_users")
	b.PutBool(m.CanBeDeletedForAllUsers)
	b.FieldStart("can_get_statistics")
	b.PutBool(m.CanGetStatistics)
	b.FieldStart("can_get_message_thread")
	b.PutBool(m.CanGetMessageThread)
	b.FieldStart("can_get_viewers")
	b.PutBool(m.CanGetViewers)
	b.FieldStart("can_get_media_timestamp_links")
	b.PutBool(m.CanGetMediaTimestampLinks)
	b.FieldStart("has_timestamped_media")
	b.PutBool(m.HasTimestampedMedia)
	b.FieldStart("is_channel_post")
	b.PutBool(m.IsChannelPost)
	b.FieldStart("contains_unread_mention")
	b.PutBool(m.ContainsUnreadMention)
	b.FieldStart("date")
	b.PutInt32(m.Date)
	b.FieldStart("edit_date")
	b.PutInt32(m.EditDate)
	b.FieldStart("forward_info")
	if err := m.ForwardInfo.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode message#e31da9f9: field forward_info: %w", err)
	}
	b.FieldStart("interaction_info")
	if err := m.InteractionInfo.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode message#e31da9f9: field interaction_info: %w", err)
	}
	b.FieldStart("reply_in_chat_id")
	b.PutLong(m.ReplyInChatID)
	b.FieldStart("reply_to_message_id")
	b.PutLong(m.ReplyToMessageID)
	b.FieldStart("message_thread_id")
	b.PutLong(m.MessageThreadID)
	b.FieldStart("ttl")
	b.PutInt32(m.TTL)
	b.FieldStart("ttl_expires_in")
	b.PutDouble(m.TTLExpiresIn)
	b.FieldStart("via_bot_user_id")
	b.PutLong(m.ViaBotUserID)
	b.FieldStart("author_signature")
	b.PutString(m.AuthorSignature)
	b.FieldStart("media_album_id")
	b.PutLong(m.MediaAlbumID)
	b.FieldStart("restriction_reason")
	b.PutString(m.RestrictionReason)
	b.FieldStart("content")
	if m.Content == nil {
		return fmt.Errorf("unable to encode message#e31da9f9: field content is nil")
	}
	if err := m.Content.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode message#e31da9f9: field content: %w", err)
	}
	b.FieldStart("reply_markup")
	if m.ReplyMarkup == nil {
		return fmt.Errorf("unable to encode message#e31da9f9: field reply_markup is nil")
	}
	if err := m.ReplyMarkup.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode message#e31da9f9: field reply_markup: %w", err)
	}
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *Message) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode message#e31da9f9 to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("message"); err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: %w", err)
			}
		case "id":
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field id: %w", err)
			}
			m.ID = value
		case "sender":
			value, err := DecodeTDLibJSONMessageSender(b)
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field sender: %w", err)
			}
			m.Sender = value
		case "chat_id":
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field chat_id: %w", err)
			}
			m.ChatID = value
		case "sending_state":
			value, err := DecodeTDLibJSONMessageSendingState(b)
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field sending_state: %w", err)
			}
			m.SendingState = value
		case "scheduling_state":
			value, err := DecodeTDLibJSONMessageSchedulingState(b)
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field scheduling_state: %w", err)
			}
			m.SchedulingState = value
		case "is_outgoing":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field is_outgoing: %w", err)
			}
			m.IsOutgoing = value
		case "is_pinned":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field is_pinned: %w", err)
			}
			m.IsPinned = value
		case "can_be_edited":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field can_be_edited: %w", err)
			}
			m.CanBeEdited = value
		case "can_be_forwarded":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field can_be_forwarded: %w", err)
			}
			m.CanBeForwarded = value
		case "can_be_deleted_only_for_self":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field can_be_deleted_only_for_self: %w", err)
			}
			m.CanBeDeletedOnlyForSelf = value
		case "can_be_deleted_for_all_users":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field can_be_deleted_for_all_users: %w", err)
			}
			m.CanBeDeletedForAllUsers = value
		case "can_get_statistics":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field can_get_statistics: %w", err)
			}
			m.CanGetStatistics = value
		case "can_get_message_thread":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field can_get_message_thread: %w", err)
			}
			m.CanGetMessageThread = value
		case "can_get_viewers":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field can_get_viewers: %w", err)
			}
			m.CanGetViewers = value
		case "can_get_media_timestamp_links":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field can_get_media_timestamp_links: %w", err)
			}
			m.CanGetMediaTimestampLinks = value
		case "has_timestamped_media":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field has_timestamped_media: %w", err)
			}
			m.HasTimestampedMedia = value
		case "is_channel_post":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field is_channel_post: %w", err)
			}
			m.IsChannelPost = value
		case "contains_unread_mention":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field contains_unread_mention: %w", err)
			}
			m.ContainsUnreadMention = value
		case "date":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field date: %w", err)
			}
			m.Date = value
		case "edit_date":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field edit_date: %w", err)
			}
			m.EditDate = value
		case "forward_info":
			if err := m.ForwardInfo.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field forward_info: %w", err)
			}
		case "interaction_info":
			if err := m.InteractionInfo.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field interaction_info: %w", err)
			}
		case "reply_in_chat_id":
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field reply_in_chat_id: %w", err)
			}
			m.ReplyInChatID = value
		case "reply_to_message_id":
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field reply_to_message_id: %w", err)
			}
			m.ReplyToMessageID = value
		case "message_thread_id":
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field message_thread_id: %w", err)
			}
			m.MessageThreadID = value
		case "ttl":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field ttl: %w", err)
			}
			m.TTL = value
		case "ttl_expires_in":
			value, err := b.Double()
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field ttl_expires_in: %w", err)
			}
			m.TTLExpiresIn = value
		case "via_bot_user_id":
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field via_bot_user_id: %w", err)
			}
			m.ViaBotUserID = value
		case "author_signature":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field author_signature: %w", err)
			}
			m.AuthorSignature = value
		case "media_album_id":
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field media_album_id: %w", err)
			}
			m.MediaAlbumID = value
		case "restriction_reason":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field restriction_reason: %w", err)
			}
			m.RestrictionReason = value
		case "content":
			value, err := DecodeTDLibJSONMessageContent(b)
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field content: %w", err)
			}
			m.Content = value
		case "reply_markup":
			value, err := DecodeTDLibJSONReplyMarkup(b)
			if err != nil {
				return fmt.Errorf("unable to decode message#e31da9f9: field reply_markup: %w", err)
			}
			m.ReplyMarkup = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetID returns value of ID field.
func (m *Message) GetID() (value int64) {
	return m.ID
}

// GetSender returns value of Sender field.
func (m *Message) GetSender() (value MessageSenderClass) {
	return m.Sender
}

// GetChatID returns value of ChatID field.
func (m *Message) GetChatID() (value int64) {
	return m.ChatID
}

// GetSendingState returns value of SendingState field.
func (m *Message) GetSendingState() (value MessageSendingStateClass) {
	return m.SendingState
}

// GetSchedulingState returns value of SchedulingState field.
func (m *Message) GetSchedulingState() (value MessageSchedulingStateClass) {
	return m.SchedulingState
}

// GetIsOutgoing returns value of IsOutgoing field.
func (m *Message) GetIsOutgoing() (value bool) {
	return m.IsOutgoing
}

// GetIsPinned returns value of IsPinned field.
func (m *Message) GetIsPinned() (value bool) {
	return m.IsPinned
}

// GetCanBeEdited returns value of CanBeEdited field.
func (m *Message) GetCanBeEdited() (value bool) {
	return m.CanBeEdited
}

// GetCanBeForwarded returns value of CanBeForwarded field.
func (m *Message) GetCanBeForwarded() (value bool) {
	return m.CanBeForwarded
}

// GetCanBeDeletedOnlyForSelf returns value of CanBeDeletedOnlyForSelf field.
func (m *Message) GetCanBeDeletedOnlyForSelf() (value bool) {
	return m.CanBeDeletedOnlyForSelf
}

// GetCanBeDeletedForAllUsers returns value of CanBeDeletedForAllUsers field.
func (m *Message) GetCanBeDeletedForAllUsers() (value bool) {
	return m.CanBeDeletedForAllUsers
}

// GetCanGetStatistics returns value of CanGetStatistics field.
func (m *Message) GetCanGetStatistics() (value bool) {
	return m.CanGetStatistics
}

// GetCanGetMessageThread returns value of CanGetMessageThread field.
func (m *Message) GetCanGetMessageThread() (value bool) {
	return m.CanGetMessageThread
}

// GetCanGetViewers returns value of CanGetViewers field.
func (m *Message) GetCanGetViewers() (value bool) {
	return m.CanGetViewers
}

// GetCanGetMediaTimestampLinks returns value of CanGetMediaTimestampLinks field.
func (m *Message) GetCanGetMediaTimestampLinks() (value bool) {
	return m.CanGetMediaTimestampLinks
}

// GetHasTimestampedMedia returns value of HasTimestampedMedia field.
func (m *Message) GetHasTimestampedMedia() (value bool) {
	return m.HasTimestampedMedia
}

// GetIsChannelPost returns value of IsChannelPost field.
func (m *Message) GetIsChannelPost() (value bool) {
	return m.IsChannelPost
}

// GetContainsUnreadMention returns value of ContainsUnreadMention field.
func (m *Message) GetContainsUnreadMention() (value bool) {
	return m.ContainsUnreadMention
}

// GetDate returns value of Date field.
func (m *Message) GetDate() (value int32) {
	return m.Date
}

// GetEditDate returns value of EditDate field.
func (m *Message) GetEditDate() (value int32) {
	return m.EditDate
}

// GetForwardInfo returns value of ForwardInfo field.
func (m *Message) GetForwardInfo() (value MessageForwardInfo) {
	return m.ForwardInfo
}

// GetInteractionInfo returns value of InteractionInfo field.
func (m *Message) GetInteractionInfo() (value MessageInteractionInfo) {
	return m.InteractionInfo
}

// GetReplyInChatID returns value of ReplyInChatID field.
func (m *Message) GetReplyInChatID() (value int64) {
	return m.ReplyInChatID
}

// GetReplyToMessageID returns value of ReplyToMessageID field.
func (m *Message) GetReplyToMessageID() (value int64) {
	return m.ReplyToMessageID
}

// GetMessageThreadID returns value of MessageThreadID field.
func (m *Message) GetMessageThreadID() (value int64) {
	return m.MessageThreadID
}

// GetTTL returns value of TTL field.
func (m *Message) GetTTL() (value int32) {
	return m.TTL
}

// GetTTLExpiresIn returns value of TTLExpiresIn field.
func (m *Message) GetTTLExpiresIn() (value float64) {
	return m.TTLExpiresIn
}

// GetViaBotUserID returns value of ViaBotUserID field.
func (m *Message) GetViaBotUserID() (value int64) {
	return m.ViaBotUserID
}

// GetAuthorSignature returns value of AuthorSignature field.
func (m *Message) GetAuthorSignature() (value string) {
	return m.AuthorSignature
}

// GetMediaAlbumID returns value of MediaAlbumID field.
func (m *Message) GetMediaAlbumID() (value int64) {
	return m.MediaAlbumID
}

// GetRestrictionReason returns value of RestrictionReason field.
func (m *Message) GetRestrictionReason() (value string) {
	return m.RestrictionReason
}

// GetContent returns value of Content field.
func (m *Message) GetContent() (value MessageContentClass) {
	return m.Content
}

// GetReplyMarkup returns value of ReplyMarkup field.
func (m *Message) GetReplyMarkup() (value ReplyMarkupClass) {
	return m.ReplyMarkup
}
